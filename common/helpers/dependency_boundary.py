"""
Dependency boundary -- Sisyphus graph breakpoint

You have a very huge pipeline with thousands of jobs,
but for your experiments, all the first 90% of the jobs never change,
and the job outputs are also changed among users.
Example: preprocessed data, features, HMM alignments, CART, etc.

So far, many people have done such graph breakpoint by hand,
i.e. calculated those things, then stored the files somewhere,
and then have separate setups which directly use those files as hardcoded inputs.

Here we want to have the possibility to easily switch between fixed inputs vs the full graph,
while keeping the same hash.

For some discussion on the specific design decisions here, see:
https://github.com/rwth-i6/i6_experiments/issues/78
"""

from typing import Optional, TypeVar, Callable
from sisyphus.hash import short_hash
from i6_experiments.common.utils.dump_py_code import dump_py_code
import os
import sys
import textwrap
import importlib.util


T = TypeVar("T")


# noinspection PyShadowingBuiltins
def dependency_boundary(func: Callable[[], T], *, hash: Optional[str]) -> T:
    """
    It basically returns func(), or some object which has the same hash.

    :param func: Function which would create the whole graph to get some outputs.
        The return value could be anything, but usually would be a dict, namedtuple, dataclass or sth similar.
        This function is not called when we actually enable the dependency boundary.
    :param hash: sisyphus.hash.short_hash(func()), or None if you do not know this value yet.
        This value is used to verify the hash of the object.
        For new code when the hash is not known yet, you would pass None here, and it will print the hash on stdout.
    :return: func(), or object with same hash
    """
    obj = None
    if hash is None:
        print(
            f"Dependency boundary for {func.__qualname__}: hash not defined, calling function"
        )
        obj = func()
        assert (
            obj is not None
        )  # None not expected, also would invalidate some code here
        hash = short_hash(obj)
    # Print the hash in any case. If this is too annoying, maybe move to the if-branch above.
    # However, might be useful to have in stdout anyway, as we likely would not use this too much.
    print(f"Dependency boundary for {func.__qualname__}: hash = {hash}")
    assert hash
    cache_fn = autogenerated_py_filename_for_func(func)
    update_cache = True

    if os.path.exists(cache_fn) and obj is None:
        update_cache = False
        cache_fn_mod_name = cache_fn.lstrip("/").replace("/", ".")
        spec = importlib.util.spec_from_file_location(cache_fn_mod_name, cache_fn)
        cache_fn_mod = importlib.util.module_from_spec(spec)
        sys.modules[cache_fn_mod_name] = cache_fn_mod
        spec.loader.exec_module(cache_fn_mod)
        obj = cache_fn_mod.obj
        assert obj is not None
        hash_ = short_hash(obj)
        if hash != hash_:
            print(
                f"Dependency boundary for {func.__qualname__}: invalid hash {hash} != {hash_},"
                f" via cached object from {cache_fn!r}"
                " -> will recreate cache and calling function"
            )
            obj = None
            update_cache = True

    if obj is None:
        print(f"Dependency boundary for {func.__qualname__}: calling function")
        obj = func()
        hash_ = short_hash(obj)
        if hash != hash_:
            print(
                f"Dependency boundary for {func.__qualname__}: error, invalid hash, given {hash}, calculated {hash_},"
                " via called function, please update the hash in the dependency_boundary call"
            )

    if update_cache:  # cache file does not exist or obj is not None (hash not defined)
        print(
            f"Dependency boundary for {func.__qualname__}: create or update cache {cache_fn!r}"
        )
        with open(cache_fn, "w") as cache_f:
            cache_f.write(
                textwrap.dedent(
                    """\
                '''
                Auto-generated code via dependency_boundary.
                Do not modify by hand!
                '''

                """
                )
            )
            dump_py_code(obj, lhs="obj", file=cache_f)
    return obj


# noinspection PyShadowingBuiltins
def autogenerated_py_filename_for_func(func: Callable[[], T]) -> str:
    """
    :return: filename of autogenerated Python file
    """
    mod = sys.modules[getattr(func, "__module__")]
    mod_dir = os.path.dirname(os.path.abspath(mod.__file__))
    return f"{mod_dir}/__dependency_boundary_autogenerated_cache_{mod.__name__}.{func.__qualname__}.py"
